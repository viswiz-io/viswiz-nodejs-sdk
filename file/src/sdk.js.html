<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/sdk.js | VisWiz.io SDK</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="The VisWiz.io Node.js SDK"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="VisWiz.io SDK"><meta property="twitter:description" content="The VisWiz.io Node.js SDK"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/viswiz-io/viswiz-nodejs-sdk"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/sdk.js~VisWiz.html">VisWiz</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/sdk.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import fs from &apos;fs&apos;;
import FormData from &apos;form-data&apos;;
import glob from &apos;glob&apos;;
import got from &apos;got&apos;;
import path from &apos;path&apos;;
import pMap from &apos;p-map&apos;;
import pkg from &apos;../package.json&apos;;

class VisWiz {
	/**
	 * @class VisWiz
	 * @typicalname client
	 * @param {string} [apiKey] - The API Key value for a VisWiz.io account
	 *
	 * If omitted, the environment variable `VISWIZ_API_KEY` will be used
	 * @param {object} [options]
	 * @param {string} [options.server=https://api.viswiz.io] - The server URL prefix for all requests
	 *
	 * @example
	 * const client = new VisWiz(&apos;your-unique-api-key-here&apos;);
	 *
	 * // Assuming environment variable VISWIZ_API_KEY is set
	 * const client = new VisWiz();
	 */
	constructor(apiKey, options) {
		this.apiKey = apiKey || process.env.VISWIZ_API_KEY;
		this.server =
			(options &amp;&amp; options.server) || process.env.VISWIZ_SERVER || &apos;https://api.viswiz.io&apos;;

		if (!this.apiKey) {
			throw new Error(&apos;Missing API key value!&apos;);
		}
	}

	/**
	 * Execute a HTTP request
	 *
	 * @private
	 * @param {string} method - http method
	 * @param {string} endpoint - endpoint for the request
	 * @param {object} body - body parameters / object
	 * @param {object} [headers] - HTTP headers for the request
	 * @param {object} [options] - `got` options
	 */
	_request(method, endpoint, body, headers, options = {}) {
		const url = this.server + endpoint;

		options.headers = headers;
		options.method = method;
		if (!options.retry) {
			options.retry = {
				limit: 0,
			};
		}

		if (body) {
			if (body instanceof FormData) {
				// `form-data` has a stream bug: https://github.com/sindresorhus/got/issues/1340
				// so we&apos;re using it as a Buffer here
				options.headers = {
					...options.headers,
					...body.getHeaders(),
				};
				options.body = body.getBuffer();
			} else {
				options.json = body;
			}
		}

		return got(url, options).json();
	}

	/**
	 * Get the list of required headers for an API request
	 *
	 * @private
	 * @param {object} [additionalHeaders={}] - headers object
	 */
	_getHeaders(additionalHeaders = {}) {
		return {
			Accept: &apos;application/json&apos;,
			Authorization: &apos;Bearer &apos; + this.apiKey,
			&apos;Content-Type&apos;: &apos;application/json&apos;,
			&apos;User-Agent&apos;: `viswiz-nodejs-sdk/${pkg.version} (${pkg.repository.url})`,
			...additionalHeaders,
		};
	}

	/**
	 * Get the current account information
	 *
	 * @method
	 * @returns {Promise}
	 * @fulfil {object} - The current account object
	 *
	 * @example
	 * const account = await client.getAccount();
	 */
	getAccount() {
		return this._request(&apos;GET&apos;, &apos;/account&apos;, null, this._getHeaders());
	}

	/**
	 * Get the list of webhooks configured for the account.
	 *
	 * @method
	 * @returns {Promise}
	 * @fulfil {array&lt;object&gt;} - The list of webhooks objects
	 *
	 * @example
	 * const webhooks = await client.getWebhooks();
	 */
	getWebhooks() {
		return this._request(&apos;GET&apos;, &apos;/webhooks&apos;, null, this._getHeaders()).then(
			results =&gt; results.webhooks
		);
	}

	/**
	 * When a build comparison is finished a POST HTTP request will be triggered towards all
	 * webhooks configured for the account.
	 *
	 * @method
	 * @param {object} params
	 * @returns {Promise}
	 * @fulfil {object} - The new webhook object
	 *
	 * @example
	 * const webhook = await client.createWebhook({
	 *   name: &apos;My first webhook&apos;,
	 *   url: &apos;http://amazing.com/webhook-handler&apos;
	 * });
	 */
	createWebhook(params) {
		if (!params) {
			return Promise.reject(new Error(&apos;Missing required parameter: params&apos;));
		}

		return this._request(&apos;POST&apos;, &apos;/webhooks&apos;, params, this._getHeaders());
	}

	/**
	 * Get a list of all the projects for the account.
	 *
	 * @method
	 * @returns {Promise}
	 * @fulfil {array&lt;object&gt;} - The list of projects objects
	 *
	 * @example
	 * const projects = await client.getProjects();
	 */
	getProjects() {
		return this._request(&apos;GET&apos;, &apos;/projects&apos;, null, this._getHeaders()).then(
			results =&gt; results.projects
		);
	}

	/**
	 * Get a list of all the projects for the account.
	 *
	 * @method
	 * @param {string} projectID - The requested project ID
	 * @returns {Promise}
	 * @fulfil {Object} - The requested project object
	 *
	 * @example
	 * const project = await client.getProject(projectID);
	 */
	getProject(projectID) {
		return this.getProjects().then(projects =&gt; projects.find(item =&gt; item.id === projectID));
	}

	/**
	 * Create a new project for the account.
	 *
	 * @method
	 * @param {object} params
	 * @returns {Promise}
	 * @fulfil {object} - The new project object
	 *
	 * @example
	 * const project = await client.createProject({
	 *   baselineBranch: &apos;master&apos;,
	 *   name: &apos;My Amazing Project&apos;,
	 *   url: &apos;http://github.com/amaze/project&apos;
	 * });
	 */
	createProject(params) {
		if (!params) {
			return Promise.reject(new Error(&apos;Missing required parameter: params&apos;));
		}

		return this._request(&apos;POST&apos;, &apos;/projects&apos;, params, this._getHeaders());
	}

	/**
	 * Get the notifications settings for a project.
	 *
	 * @method
	 * @param {string} projectID - The requested project ID
	 * @returns {Promise}
	 * @fulfil {array&lt;object&gt;} - The notifications settings
	 *
	 * @example
	 * const notifications = await client.getProjectNotifications(&apos;mwwuciQG7ETAmKoyRHgkGg&apos;);
	 */
	getProjectNotifications(projectID) {
		if (!projectID) {
			return Promise.reject(new Error(&apos;Missing required parameter: projectID&apos;));
		}

		return this._request(&apos;GET&apos;, `/projects/${projectID}/notifications`, null, this._getHeaders());
	}

	/**
	 * Update the notifications settings for a project.
	 *
	 * @method
	 * @param {string} projectID - The requested project ID
	 * @param {object} params
	 * @param {string} [params.emailEnabled] - Controls if email reports are sent on new builds
	 * @param {string} [params.slackEnabled] - Controls if Slack notifications are sent on new builds
	 * @param {string} [params.slackURL] - The Slack webhook URL to use for sending notifications
	 * @returns {Promise}
	 * @fulfil {array&lt;object&gt;} - The updated notifications settings
	 *
	 * @example
	 * const build = await client.updateProjectNotifications(&apos;mwwuciQG7ETAmKoyRHgkGg&apos;, {
	 *   emailEnabled: false,
	 *   slackEnabled: true,
	 *   slackURL: &apos;https://hooks.slack.com/services/FOO/BAR/A18759GACAsgawg351ac&apos;,
	 * });
	 */
	updateProjectNotifications(projectID, params) {
		if (!projectID) {
			return Promise.reject(new Error(&apos;Missing required parameter: projectID&apos;));
		}

		return this._request(&apos;PUT&apos;, `/projects/${projectID}/notifications`, params, this._getHeaders());
	}

	/**
	 * Get a list of all the builds for a project.
	 *
	 * @method
	 * @param {string} projectID - The requested project ID
	 * @returns {Promise}
	 * @fulfil {array&lt;object&gt;} - The list of builds objects
	 *
	 * @example
	 * const builds = await client.getBuilds(&apos;mwwuciQG7ETAmKoyRHgkGg&apos;);
	 */
	getBuilds(projectID) {
		if (!projectID) {
			return Promise.reject(new Error(&apos;Missing required parameter: projectID&apos;));
		}

		return this._request(&apos;GET&apos;, `/projects/${projectID}/builds`, null, this._getHeaders()).then(
			results =&gt; results.builds
		);
	}

	/**
	 * Create a new build for a project.
	 *
	 * @method
	 * @param {object} build
	 * @param {string} build.branch - The branch name for this build
	 * @param {string} build.projectID - The requested project ID
	 * @param {string} build.name - The commit name for this build
	 * @param {string} build.revision - The revision for this build
	 * @returns {Promise}
	 * @fulfil {object} - The new build object
	 *
	 * @example
	 * const build = await client.createBuild({
	 *   branch: &apos;master&apos;,
	 *   projectID: &apos;mwwuciQG7ETAmKoyRHgkGg&apos;,
	 *   name: &apos;New amazing changes&apos;,
	 *   revision: &apos;62388d1e81be184d4f255ca2354efef1e80fbfb8&apos;
	 * });
	 */
	createBuild(build) {
		if (!build || !build.projectID) {
			return Promise.reject(new Error(&apos;Missing required parameter: projectID&apos;));
		}

		const { projectID, ...body } = build;

		return this._request(&apos;POST&apos;, `/projects/${build.projectID}/builds`, body, this._getHeaders());
	}

	/**
	 * Finish a build when all images have been created. This triggers the actual build comparison to execute.
	 *
	 * @method
	 * @param {string} buildID - The requested build ID
	 * @returns {Promise}
	 *
	 * @example
	 * await client.finishBuild(&apos;gjVgsiWeh4TYVseqJsU6ev&apos;);
	 */
	finishBuild(buildID) {
		if (!buildID) {
			return Promise.reject(new Error(&apos;Missing required parameter: buildID&apos;));
		}

		return this._request(&apos;POST&apos;, `/builds/${buildID}/finish`, null, this._getHeaders());
	}

	/**
	 * Get the results for a build which has been compared to another build.
	 *
	 * @method
	 * @param {string} buildID - The requested build ID
	 * @returns {Promise}
	 * @fulfil {object} - The build results object
	 *
	 * @example
	 * const buildResults = await client.getBuildResults(&apos;gjVgsiWeh4TYVseqJsU6ev&apos;);
	 */
	getBuildResults(buildID) {
		if (!buildID) {
			return Promise.reject(new Error(&apos;Missing required parameter: buildID&apos;));
		}

		return this._request(&apos;GET&apos;, `/builds/${buildID}/results`, null, this._getHeaders());
	}

	/**
	 * Get a list of all images for a build.
	 *
	 * @method
	 * @param {string} buildID - The requested build ID
	 * @returns {Promise}
	 * @fulfil {array&lt;object&gt;} - The list of images objects
	 *
	 * @example
	 * const images = await client.getImages(&apos;gjVgsiWeh4TYVseqJsU6ev&apos;);
	 */
	getImages(buildID) {
		if (!buildID) {
			return Promise.reject(new Error(&apos;Missing required parameter: buildID&apos;));
		}

		return this._request(&apos;GET&apos;, `/builds/${buildID}/images`, null, this._getHeaders());
	}

	/**
	 * Upload a new image for a build. This endpoint accepts only one PNG image per request.
	 *
	 * @method
	 * @param {string} buildID - The requested build ID
	 * @param {string} name - The image name
	 * @param {string} filePath - The image file path
	 * @returns {Promise}
	 * @fulfil {object} - The new image object
	 *
	 * @example
	 * const image = await client.createImage(&apos;gjVgsiWeh4TYVseqJsU6ev&apos;, &apos;image-name&apos;, &apos;/path/to/image.png&apos;);
	 */
	createImage(buildID, name, filePath) {
		if (!buildID) {
			return Promise.reject(new Error(&apos;Missing required parameter: buildID&apos;));
		}
		if (!name) {
			return Promise.reject(new Error(&apos;Missing required parameter: name&apos;));
		}
		if (!filePath) {
			return Promise.reject(new Error(&apos;Missing required parameter: filePath&apos;));
		}
		if (!fs.existsSync(filePath)) {
			return Promise.reject(new Error(&apos;File not found: &apos; + filePath));
		}

		const form = new FormData();
		form.append(&apos;name&apos;, name);
		form.append(&apos;image&apos;, fs.readFileSync(filePath), {
			filename: path.basename(filePath),
		});

		return this._request(
			&apos;POST&apos;,
			`/builds/${buildID}/images`,
			form,
			this._getHeaders(form.getHeaders()),
			{
				retry: {
					limit: 2,
					methods: [&apos;POST&apos;],
				},
			}
		);
	}

	/**
	 * Creates a new build and uploads all images (`*.png`) found in a folder (scanned recursively)
	 *
	 * @method
	 * @param {object} build
	 * @param {string} build.branch - The branch name for this build
	 * @param {string} build.projectID - The requested project ID
	 * @param {string} build.name - The commit name for this build
	 * @param {string} build.revision - The revision for this build
	 * @param {string} folderPath
	 * @param {function} [progressCallback] - called with parameters: (current, total)
	 * @param {number} [concurrency] - The amount of concurrent images to upload (defaults to 4)
	 * @returns {Promise}
	 *
	 * @example
	 * await client.buildFolder({
	 *   branch: &apos;master&apos;,
	 *   projectID: &apos;mwwuciQG7ETAmKoyRHgkGg&apos;,
	 *   name: &apos;New amazing changes&apos;,
	 *   revision: &apos;62388d1e81be184d4f255ca2354efef1e80fbfb8&apos;
	 * }, &apos;/path/to/folder/with/images&apos;);
	 */
	async buildFolder(build, folderPath, progressCallback, concurrency = 4) {
		const fullPath = path.resolve(folderPath);
		const imageFiles = glob.sync(path.join(fullPath, &apos;**/*.png&apos;));
		const total = imageFiles.length;
		if (!total) {
			return Promise.reject(new Error(&apos;No image files found in image directory!&apos;));
		}

		const buildResponse = await this.createBuild(build);
		const buildID = buildResponse.id;

		let index = 0;

		await pMap(
			imageFiles,
			imageFile =&gt; {
				let name = imageFile;
				// glob under Windows returns `/` instead of `\`
				if (process.platform === &apos;win32&apos;) {
					name = name.replace(/\//g, &apos;\\&apos;);
				}
				name = name
					.replace(fullPath, &apos;&apos;)
					.replace(/^[/\\]/, &apos;&apos;)
					.replace(/\.png$/i, &apos;&apos;);

				return this.createImage(buildID, name, imageFile).then(
					() =&gt; progressCallback &amp;&amp; progressCallback(++index, total)
				);
			},
			{ concurrency }
		);

		await this.finishBuild(buildID);

		return buildID;
	}

	/**
	 * Alias for `buildFolder`
	 *
	 * @method
	 */
	buildWithImages(build, folderPath, progressCallback, concurrency) {
		return this.buildFolder(build, folderPath, progressCallback, concurrency);
	}
}

export default VisWiz;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
